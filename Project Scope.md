# Project Scope## "Joseph's Software Toys"### Core ObjectiveCreate a suite of 6 installable PWAs (Progressive Web Apps) as "software toys"—each a limited-focus, interactive demo with graphical effects, shared UI, sound, storage, and a demonstration mode. Shared homepage for selection and global settings.---### Key Features* Mobile and Assisted controls: Touch/pinch controls, vibration, orientation hints, mouse-over hints, aria-labels.* Shared UI: Header (Demo, Reset, Export, Settings), Footer (type-specific controls + status).* Global Settings: Theme, sound, vibration (localStorage, homepage modal).* Performance: WebGL fallback, throttling, auto-optimize (e.g., reduce detail on low FPS). Take advantage of new web technologies.* Loading: Spinner overlay, no flash (load UI first, render async). Loading screen for each toy needs a tagline.* Interactions: Drag/drop (e.g., files for audio), export PNG: export size of canvas viewport, custom size export, export quality (HD, Ultra 2x, Ultra 4x).* Educational: "About" modal with explanations/links to 3rd party websites.* Settings pane: Each toy can open a "Settings" pane that quickly slides in from the right. In the top-right corner of the Settings pane is a close button. At the top of the Settings pane are additional controls for the software toy. The bottom half of the Settings pane will be the same for each software toy: Toggle for sound (if any), toggle for vibration, toggle to show the frames per second on top and in the top-left corner of the renderer canvas, controls for the "Export as PNG" feature.* Global acceptance criteria: Site shell loads in ≤ 500 ms; both header UI and footer UI are visible and interactive before first render. Every software toy renders at the user's display refresh rate (for example, 60fps or 120fps). When the frames per second drops below 30, we begin to auto-optimize until the frames per second stabalises at 30fps.---### Layout and Load-Order Rules* The layout of each software will be: at the top of the screen is the header UI, in the middle is the renderer canvas that doesn't clip behind the header UI or footer UI, at the bottom of the screen is the footer UI.* Startup ordering contract: In the following order create header UI and footer UI, compute layout, initialise renderer, first render hide loader.* Single module entry: index.html loads only one <script type="module" src="main.js">. No duplicate shared script tags. Use ES modules.### Event Ownership and Interaction Rules* Attach pointer/wheel handlers only to canvas. Use { passive: false } for wheel to allow preventDefault().* Preview vs final: Input events trigger preview render (low-cost); commit triggers full render with scheduleFullResRender().* Gesture handling: Single pointer = pan preview; two pointers = pinch preview; double-tap = zoom in.### Service worker and caching policy* Precaching: cache index.html, main.js, shared/\*, and essential assets.* Update strategy: use cache-first for static assets, network-first for main.js during development; show a non-blocking update toast when a new SW is available.* Dev mode: disable SW during active refactor to avoid stale files.### Accessibility and UX checklist* Keyboard: All controls reachable by Tab; header buttons have aria-label. Keyboard shortcuts are: "H" for returning to the homescreen, "D" to start or stop the Demo mode, "P" to pause the render/simulation, "S" to open the Settings pane.* Screen reader: Settings panel announces open/close; canvas has descriptive role="application" and an accessible summary.* Contrast: Meet WCAG AA for primary controls; test with high-contrast mode.### Testing and CI* Local smoke test (Puppeteer/Playwright): Header UI exists, canvas sized between header UI and footer UI, worker created once, wheel handler attached, zoom changes readout.* Error reporting: Use detailed console messages for debugging such as reporting fatal startup errors.* Unit tests: Small tests for utils (theme, storage).* CI: Run lint + smoke test on PRs; fail fast on missing header or duplicate script loads.### Migration and rollback rules* Baseline commit: Tag a working snapshot before any refactor.* Small commits: Each change must pass smoke test locally.* Rollback: Revert to baseline branch if smoke test fails on CI. Backup snapshots of project will be saved locally and on GitHub.### Developer ergonomics and docs* CONTRACTS.md: Document renderer and UI APIs.* Onboarding README: How to run, how to add a new toy, import path conventions (../shared/...).* Style: Prefer ESM named exports; keep window.\* fallback only for legacy compatibility.---### Shared Header UIFor consistency, every software toy features the same header UI. The header UI code will be contained within a "shared" folder where each software toy can "request" the header UI. The header UI buttons needs to be grouped together logically, so that when a user changes resizes the browser window or is on a mobile device, the header UI can be grouped together without feeling crowded.* Top left: "Home" button that sends the user back to the homepage. "Demo" button, each software toy will implement their own logic to demonstrate demos to the user. "Export" button* Center: The title of the software toy.* Top right: "Reset" button that resets the software toy, toggle for Light and Dark theme using icons, an info button (represented by a question mark) that displays a popup with information about the software toy, a settings button (represented by a cog symbol) that opens the per-toy settings pane.### Footer UIEvery software toy will have a footer UI, this can be either 1 row, 2 rows or 3 rows. All content in the footer UI is centered in layout. The height of the footer UI with 1 row will be consistent with other footer UIs that are 1 row tall, same for 2 rows and 3 rows.The footer UI code will be contained within a "shared" folder where each software toy can "request" a footer UI with components such as buttons, toggles or sliders. Each software toy will define how these buttons interact with the software toy. For example the Fractal Explorer needs zoom-control buttons that control the renderer, the Particle Fountain Simulator needs time-based controls. These buttons might re-appear in other software toys but their interaction is governed by each software toy.---### Tech Stack* Vanilla JS/Canvas/WebGL* Tailwind/DaisyUI (CDN)* Web Audio/Vibration APIs* localStorage* Service workers for PWA---### ConstraintsNo external libraries (except CDNs), beginner-friendly code, cross-platform (desktop/mobile).### MilestonesHomepage first, then one toy per session, optimize last.### Out of ScopeMulti-user, server backend, complex 3D (stick to simple WebGL).---### Toy List##### 1\. Fractal Explorer* Concept: A zoomable viewer for fractals. Users can choose from 3 fractals: Mandelbrot set, Julia set and Burning Ship set. Users click to zoom in/zoom out on intricate patterns; demo mode cycles through 5 famous regions for each fractal.* Why Impressive: Uses a simple iterative math formula (z = z² + c) to generate infinite, psychedelic patterns that look complex but stem from basic loops—feels like magic for minimal code.* Key Skills: Canvas for rendering pixels, event listeners for clicks/touches, basic math for coordinates.* PWA Perks: Offline caching of the app; let the user store favourite zoom spots in localStorage or as a custom URL.* Interactive/Demo: Drag to pan, pinch-zoom on mobile; clicking demo button cycles through 5 famous regions for each fractal like the "seahorse valley" in the Mandelbrot set.* Footer UI: 2 rows. 1st row zoom controls (-50, -20, -10, -5, -1, "Zoom", 1, 5, 10, 20, 50). 2nd row shows a persistent status of the zoom level.* When the software toy first loads, the fractal is rendered.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; pinch-zoom preview < 100 ms; export PNG at 2× DPR within 2s.##### 2\. Particle Fountain Simulator* Concept: A fountain of colourful particles that burst and fall with gravity, reacting to mouse/touch input. We can provide 3 types of particle fountains: Party confetti poppers (multiple colours), fireworks (multiple varieties), and galactic aurora (* Demo mode cycles each particle fountain type with a demonstration.* Why Impressive: Simple vector math (position + velocity + acceleration) creates emergent chaos—like a screensaver that's alive and responsive.* Key Skills: Canvas for drawing particles, requestAnimationFrame for smooth loops, basic physics equations. Sound: Popping effects on bursts via Web Audio.* PWA Perks: Cross-device (looks great on phones); persist particle colours/themes in IndexedDB.* Interactive/Demo: Click to spawn bursts; demo auto-generates patterns.* When the software toy first loads, there are no particle effects, only a message on screen advising the user to tap or click anywhere to begin.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; export PNG at 2× DPR within 2s.##### 3\. Audio Wave Visualizer* Concept: Visualize microphone input or load a sound file. Users hum or play music to see real-time shapes; demo mode plays a built-in melody with syncing visuals. Footer UI has a "Mic" button for microphone input.* Why Impressive: The Web Audio API's analyser node turns sound into data effortlessly, creating hypnotic, music-reactive graphics that feel professional.* Key Skills: Web Audio API for input/processing, Canvas for drawing waveforms. Neat trick: FFT (frequency transform) for bar graphs without complex math.* PWA Perks: Works offline with cached audio samples; store custom recordings in localStorage (as base64).* Interactive/Demo: Toggle mic input, adjust sensitivity; demo loops a sine wave with evolving visuals.* When the software toy first loads, we show the visualisation.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; export PNG at 2× DPR within 2s.##### 4\. Cellular Automata Playground (Game of Life)* Concept: A grid where cells "live" or "die" based on neighbours. Users draw patterns to start; demo mode cycles through classic oscillators/gliders.* Why Impressive: One rule set (e.g., 3 neighbours = birth) generates endless complexity like spaceships or patterns—proves "simple rules, big results."* Key Skills: 2D arrays for the grid, nested loops for updates, Canvas for rendering. Add sound: Beeps on cell births.* PWA Perks: Offline simulation; save/load patterns via localStorage.* Interactive/Demo: Click to toggle cells, step/pause; demo auto-loads and runs famous setups.* When the software toy first loads, we show the grid with a message telling the user to tap or click anywhere to create life.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; pinch-zoom preview < 100 ms; export PNG at 2× DPR within 2s.##### 5\. 3D Rotating Orb (Solar System Mini)* Concept: A simple 3D scene with a central orb (sun) and orbiting spheres (planets). Users rotate/view with mouse drag; demo mode auto-spins with trails. Inspired by our own galaxy with planets such as Earth with the Sun at the center.* Why Impressive: Basic matrix math for rotations creates a smooth 3D illusion using 2D Canvas tricks (no full WebGL needed initially), or step up to Three.js for ease.* Key Skills: Trig functions (sin/cos) for orbits, perspective projection for depth. Sound: Ambient hum based on speed.* PWA Perks: Fullscreen on mobile; store custom planet configs in IndexedDB.* Interactive/Demo: Drag to orbit camera, click planets for info; demo accelerates/decelerates smoothly.* When the software toy first loads, we show the planet Earth and zoom out to show the whole galaxy.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; pinch-zoom preview < 100 ms; export PNG at 2× DPR within 2s.##### 6\. Generative Landscape Drawer* Concept: Generate rolling hills/terrains using noise functions. Users "seed" new landscapes; demo mode animates a day-night cycle with colour shifts. User "drives" a vehicle through the generated landscape, this is an illusion as the vehicle remains stationary but instead the landscape moves as it is generated.* Why Impressive: Perlin noise (a simple random-but-smooth algorithm) creates natural-looking worlds from one function—feels like procedural game art.* Key Skills: Canvas paths for drawing, noise algorithm (implement or use p5.js). Sound: Wind/wave effects tied to terrain height.* PWA Perks: Export images offline; persist seeds in localStorage for reproducibility.* Interactive/Demo: Sliders for roughness/scale; demo regenerates and pans automatically.* When the software toy first loads, we show the "vehicle" and the generated background but no movement. We display a message to the user to tap or click anywhere to begin.* Acceptance criteria: Initial render ≤ 1s on mid-range phone; export PNG at 2× DPR within 2s.